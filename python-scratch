Data Camp Notes
=======================================

type(a)
convert into another datatype str(), int(), float() and bool()
 
 to delete an element from a list 
 
 x = ["a", "b", "c", "d"]
del(x[1])

careful when copying lists 
# Create list areas
areas = [11.25, 18.0, 20.0, 10.75, 9.50]
# Create areas_copy
areas_copy = list(areas)
# Change areas_copy
areas_copy[0] = 5.0
# Print areas
print(areas)

help function
==================
help(max)


sort a list
================
full = [11.25, 18.0, 20.0]
# Sort full in descending order: full_sorted
full_sorted = sorted(full, reverse=True)



list methods - index and count
append()
remove()
reverse()

numpy array 
=================

create a numpy array from list
baseball = [180, 215, 210, 210, 188, 176, 209, 200]
np_baseball = np.array(baseball)

high = np_baseball > 215
np_baseball[high]

numpy is great for doing vector arithmetic. numpy arrays cannot contain elements with different types.


print the shape of a numpy array
==================================
shape()

np.mean()
np.median()
np.std()
to find correlation
np.corrcoef()


positions = ['GK', 'M', 'A', 'D', ...]
heights = [191, 184, 185, 180, ...]
np_positions = np.array(positions)
np_heights = np.array(heights)
gk_heights = np_heights[np_positions == 'GK']
other_heights = np_heights[np_positions != 'GK' ]
print("Median height of goalkeepers: " + str(np.median(gk_heights)))
print("Median height of other players: " + str(np.median(other_heights)))


matplotlib
========================

line plot

there are 2 lists:
1. year
2. pop ( population )

import matplotlib.pyplot as plt

plt.plot(year,pop)
plt.show()

----

life_exp 
gdp_cap
plt.scatter(gdp_cap, life_exp)
plt.xscale('log')
plt.show()

------

histogram
plt.hist(life_exp, bins = 5)
plt.show()
plt.clf()  # cleans up so to start again
plt.hist(life_exp, bins = 20)
plt.show()
plt.clf()


--- with labels ------------
# Basic scatter plot, log scale
plt.scatter(gdp_cap, life_exp)
plt.xscale('log') 
# Strings
xlab = 'GDP per Capita [in USD]'
ylab = 'Life Expectancy [in years]'
title = 'World Development in 2007'
# Add axis labels
plt.xlabel(xlab)
plt.ylabel(ylab)
# Add title
plt.title(title)

tick_val = [1000,10000,100000]
tick_lab = ['1k','10k','100k']
plt.xticks(tick_val, tick_lab)

# After customizing, display the plot
plt.show()

-------
add a thrid variable to the plot

np_pop = np.array(pop)
np_pop = np_pop*2
plt.scatter(gdp_cap, life_exp, s = np_pop)
plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000, 10000, 100000],['1k', '10k', '100k'])
plt.show()

--------------------

add color

plt.scatter(x = gdp_cap, y = life_exp, s = np.array(pop) * 2, c = col, alpha=0.8)

plt.xscale('log') 
plt.xlabel('GDP per Capita [in USD]')
plt.ylabel('Life Expectancy [in years]')
plt.title('World Development in 2007')
plt.xticks([1000,10000,100000], ['1k','10k','100k'])

# Additional customizations
plt.text(1550, 71, 'India')
plt.text(5700, 80, 'China')

# Add grid() call
plt.grid(True)

plt.show()
plt.clf()

------------------------

dictionaries
countries = ['spain', 'france', 'germany', 'norway']
capitals = ['madrid', 'paris', 'berlin', 'oslo']

ind_ger = countries.index('germany')
print(capitals[ind_ger])


europe = {'spain':'madrid', 'france':'paris', 'germany':'berlin', 'norway':'oslo' }
# Add italy to europe
europe['italy'] = 'rome'
# Print out italy in europe
print('italy' in europe)
# Add poland to europe
europe['poland'] = 'warsaw'
# Print europe
print(europe)

# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'bonn', 
          'norway':'oslo', 'italy':'rome', 'poland':'warsaw', 
          'australia':'vienna' }
# Update capital of germany
europe['germany'] = 'berlin'
# Remove australia
del(europe['australia'])
# Print europe
print(europe)

------------- dictionary of dictionaries -----------------
# Dictionary of dictionaries
europe = { 'spain': { 'capital':'madrid', 'population':46.77 },
           'france': { 'capital':'paris', 'population':66.03 },
           'germany': { 'capital':'berlin', 'population':80.62 },
           'norway': { 'capital':'oslo', 'population':5.084 } }
           
           
# Print out the capital of France
print(europe['france']['capital'])

# Create sub-dictionary data
data = { 'capital':'rome', 'population':59.83}

# Add data to europe under key 'italy'
europe['italy'] = data

# Print europe
print(europe)


------------------------------------- pandas ----------------
# Pre-defined lists
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]

my_dict = { 'country':names,
         'drives_right':dr,
         'cars_per_cap':cpc}
cars = pd.DataFrame(my_dict)
print(cars)


--- row labels ----------
# Build cars DataFrame
names = ['United States', 'Australia', 'Japan', 'India', 'Russia', 'Morocco', 'Egypt']
dr =  [True, False, False, False, True, True, True]
cpc = [809, 731, 588, 18, 200, 70, 45]
dict = { 'country':names, 'drives_right':dr, 'cars_per_cap':cpc }
cars = pd.DataFrame(dict)
print(cars)

# Definition of row_labels
row_labels = ['US', 'AUS', 'JAP', 'IN', 'RU', 'MOR', 'EG']

# Specify row labels of cars
cars.index = row_labels

# Print cars again
print(cars)

----------------

read csv file

cars = pd.read_csv('cars.csv', index_col = 0)
# Print out country column as Pandas Series
print(cars['country'])

# Print out country column as Pandas DataFrame
print(cars[['country']])

# Print out DataFrame with country and drives_right columns
print(cars[['country', 'drives_right']])

# Print out first 3 observations
print(cars[0:3])

# Print out fourth, fifth and sixth observation
print(cars[3:6])

loc and iloc
# Print out observation for Japan
print(cars.loc['JAP'])

# Print out observations for Australia and Egypt
print(cars.loc[['AUS', 'EG']])

# Print out drives_right value of Morocco
print(cars.loc['MOR', 'drives_right'])

# Print sub-DataFrame
print(cars.loc[['RU','MOR'],['country','drives_right']])

# Print out drives_right column as Series
print(cars.iloc[:, 2])

# Print out drives_right column as DataFrame
print(cars.iloc[:,[ 2]])

# Print out cars_per_cap and drives_right as DataFrame
print(cars.iloc[:, [0,2]])



----------------- comparison -----------

my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])

print(my_house[(my_house >= 18) == True ])
print(my_house[(my_house < your_house ) == True])

and or not

my_kitchen = 18.0
your_kitchen = 14.0
print(my_kitchen > 10 and my_kitchen > 18)
print(my_kitchen < 14 or my_kitchen > 17)
print(2*my_kitchen < 3*your_kitchen)

----------------   boolean operators numpy   ---------------
+my_house = np.array([18.0, 20.0, 10.75, 9.50])
your_house = np.array([14.0, 24.0, 14.25, 9.0])
print(np.logical_or(my_house > 18.5, my_house < 10))
print(np.logical_and(my_house < 11, your_house<11))
print(np.logical_and(my_house < 11, your_house<11))


if else
------------------
area = 10.0
if(area < 9) :
    print("small")
elif(area < 12) :
    print("medium")
else :
    print("large")


if room == "kit" :
    print("looking around in the kitchen.")
    
# if-else construct for room
if room == "kit" :
    print("looking around in the kitchen.")
else :
    print("looking around elsewhere.")
    

if area > 15 :
    print("big place!")
elif area > 10 :
    print("medium size, nice!")
else :
    print("pretty small.")
    


----------------

cars = pd.read_csv('cars.csv', index_col = 0)

cpc = cars['cars_per_cap']
between = np.logical_and(cpc > 100, cpc < 500)
medium = cars[between]


-----------------------

while loop
offset = 8

while offset != 0 :
    print("correcting...")
    offset = offset - 1
    print(offset)
    
offset = -6
while offset != 0 :
    print("correcting...")
    if offset > 0 :
        offset = offset - 1
    else:
        offset = offset + 1
    print(offset)


for loop
------------------------
# areas list
areas = [11.25, 18.0, 20.0, 10.75, 9.50]

# Code the for loop
for index, area in enumerate(areas) :
    print("room " + str(index + 1) + ": " + str(area))
    

looping over dictionary
==================================

# Definition of dictionary
europe = {'spain':'madrid', 'france':'paris', 'germany':'bonn', 
          'norway':'oslo', 'italy':'rome', 'poland':'warsaw', 'australia':'vienna' }
          
# Iterate over europe
for key, value in europe.items() :
    print("the capital of " + str(key) + " is " + str(value))
    

loop over numpy arrays
===================================
 1- D array
 
 for x in np_height :
    print(str(x) + " inches")
    
 2 -D Array
 
 # For loop over np_baseball
for x in np.nditer(np_baseball) :
    print(str(x))
    

Loop over dataframe
====================================

cars = pd.read_csv('cars.csv', index_col = 0)

# Iterate over rows of cars
for lab, row in cars.iterrows() :
    print(lab)
    print(row)
    
another format
-------------------------
for lab, row in cars.iterrows() :
    print(str(lab) + ": " + str(row['cars_per_cap']))
    


add a new column
------------------------

for lab, row in cars.iterrows() :
    cars.loc[lab, "COUNTRY"] = row["country"].upper()
    
another way using the apply function
-----------------------------------------

# Use .apply(str.upper)
cars["COUNTRY"] = cars["country"].apply(str.upper)

random numbers 
--------------------------

# Set the seed
np.random.seed(123)

# Generate and print random float
print(np.random.rand())

# Use randint() to simulate a dice
print(np.random.randint(1,7))


random walk 
----------------------------
# Initialize random_walk
random_walk = [0,3,4]

# Complete the ___
for x in range(100) :
    # Set step: last element in random_walk
    step = random_walk[-1]
    
    # Roll the dice
    dice = np.random.randint(1,7)
    
    # Determine next step
    if dice <= 2:
        step = step - 1
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)  
 
 visualize a random walk
 ---------------------------------------
  
np.random.seed(123)
random_walk = [0]

for x in range(100) :
    step = random_walk[-1]
    dice = np.random.randint(1,7)
  
    if dice <= 2:
        step = max(0, step - 1)
    elif dice <= 5:
        step = step + 1
    else:
        step = step + np.random.randint(1,7)  
      
    random_walk.append(step)

# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Plot random_walk
plt.plot(random_walk)

# Show the plot
plt.show()

plot multiple random walks
---------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []
for i in range(10) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)  
        random_walk.append(step)
    all_walks.append(random_walk)

# Convert all_walks to Numpy array: np_aw
np_aw = np.array(all_walks)

# Plot np_aw and show
plt.plot(np_aw)
plt.show()
# Clear the figure
plt.clf()

# Transpose np_aw: np_aw_t
np_aw_t = np.transpose(np_aw)

# Plot np_aw_t and show
plt.plot(np_aw_t)
plt.show()


implement clumsiness in walking and visualize it
--------------------------------------------------------

import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []

# Simulate random walk 250 times
for i in range(250) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)  
        
        # Implement clumsiness
        if np.random.rand() <= 0.001 :
            step = 0
            
        random_walk.append(step)
    all_walks.append(random_walk)

# Create and plot np_aw_t
np_aw_t = np.transpose(np.array(all_walks))
plt.plot(np_aw_t)
plt.show()



---------- plot the distribution --------------------------

import matplotlib.pyplot as plt
import numpy as np
np.random.seed(123)
all_walks = []

# Simulate random walk 5000 times
for i in range(5000) :
    random_walk = [0]
    for x in range(100) :
        step = random_walk[-1]
        dice = np.random.randint(1,7)
        if dice <= 2:
            step = max(0, step - 1)
        elif dice <= 5:
            step = step + 1
        else:
            step = step + np.random.randint(1,7)  
        if np.random.rand() <= 0.001 :
            step = 0
        random_walk.append(step)
    all_walks.append(random_walk)

# Create and plot np_aw_t
np_aw_t = np.transpose(np.array(all_walks))

# Select last row from np_aw_t: ends
ends = np_aw_t[-1]

# Plot histogram of ends, display plot
plt.hist(ends)
plt.show()


------------------------------------








Writing to a file
=======================

text = 'Sample Text to Save\nNew line!'

# notifies Python that you are opening this file, with the intention to write
saveFile = open('exampleFile.txt','w')

# actually writes the information
saveFile.write(text)

# It is important to remember to actually close the file, otherwise it will
# hang for a while and could cause problems in your script
saveFile.close()

Appending a file
==========================
appendMe = '\nNew bit of information'

appendFile = open('exampleFile.txt','a')
appendFile.write(appendMe)
appendFile.close()

Reading lines
===============================

# similar syntax as you've seen, 'r' for read. You can just throw a .read() at
# the end, and you get:
readMe = open('exampleFile.txt','r').read()
print(readMe)

# this will instead read the file into a python list. 
readMe = open('exampleFile.txt','r').readlines()
print(readMe)

if __name__ == '__main__':
    print('such great module!!!!')
    
    
Multiline print
====================

print(''' 

This is a massive print, where you want to
use multiple lines, maybe make designs, or
something like that. 

''')

USer Input
=========================

x = input('What is your name?: ')
print('Hello',x)

List 
===========================

x = [1,6,3,2,6,1,2,6,7]
# lets add something.
# we can do .append, which will add something to the end of the list, like:
x.append(55)
print(x)

x.insert(2,33)
print(x)

x.remove(6)
print(x)

print(x.index(1))
print(x.count(1))
x.sort()
y = ['Jan','Dan','Bob','Alice','Jon','Jack']
y.sort()
print(y)
y.reverse()
print(y)

Reading csv files
=================================

import csv

with open('example.csv') as csvfile:
    readCSV = csv.reader(csvfile, delimiter=',')
    dates = []
    colors = []
    for row in readCSV:
        color = row[3]
        date = row[0]

        dates.append(date)
        colors.append(color)

    print(dates)
    print(colors)

    # now, remember our lists?

    whatColor = input('What color do you wish to know the date of?:')
    coldex = colors.index(whatColor)
    theDate = dates[coldex]
    print('The date of',whatColor,'is:',theDate)
    
Exception Handling
====================================

with open('example.csv') as csvfile:
    readCSV = csv.reader(csvfile, delimiter=',')
    dates = []
    colors = []
    for row in readCSV:
        color = row[3]
        date = row[0]

        dates.append(date)
        colors.append(color)

    print(dates)
    print(colors)

    # we could put the try anywhere. The weak point, however, starts
    # in my opinion immediately when we accept user input... no longer
    # is this is a closed-program, so I would personally code this block
    # here, but you could put the try right about the print statement
    # of where we search for the color and we KNOW it will throw an error
    # if not in the list. 
    try:
        whatColor = input('What color do you wish to know the date of?:')

        if whatColor in colors:
            coldex = colors.index(whatColor)
            theDate = dates[coldex]
            print('The date of',whatColor,'is:',theDate)
        else:
            # now we can handle a specific scenario, instead
            # of handling it with a "catch-all" error.
            # now we have error handling and
            # proper logic. Yay.
            print('This color was not found.')

    # in python 2, this is read exception Exception, e. It's just helpful
    # to know this for porting old scripts if you need to.


    except Exception as e:
        print(e)
        

Dictionaries
============================

exDict = {'Jack':15,'Bob':22,'Alice':12,'Kevin':17}
del exDict['Tim']

OS Module
============================
import os
os.getcwd()
os.mkdir('newDir')
os.rename('newDir','newDir2')
os.rmdir('newDir2')

names = ['Jeff', 'Gary', 'Jill', 'Samantha']
print(', '.join(names))

location_of_files = 'C:\\Users\\H\\Desktop\\Intermediate Python'
file_name = 'example.txt'

with open(os.path.join(location_of_files, file_name)) as f:
    print(f.read())
    
who = 'Gary'
how_many = 12

print('{} bought {} apples today!'.format(who, how_many))   
===================================================
import argparse
import sys

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--x', type=float, default=1.0,
                        help='What is the first number?')
    parser.add_argument('--y', type=float, default=1.0,
                        help='What is the second number?')
    parser.add_argument('--operation', type=str, default='add',
                        help='What operation? Can choose add, sub, mul, or div')
    args = parser.parse_args()
    sys.stdout.write(str(calc(args)))
    
def calc(args):
    if args.operation == 'add':
        return args.x + args.y
    elif args.operation == 'sub':
        return args.x - args.y
    elif args.operation == 'mul':
        return args.x * args.y
    elif args.operation == 'div':
        return args.x / args.y

if __name__ == '__main__':
    main()
    
    
===================================================    
    
example_dict = {'left':'<','right':'>','up':'^','down':'v',}
[print(i,j) for i,j in enumerate(example_dict)]

new_dict = dict(enumerate(example))
print(new_dict)

x = [1,2,3,4]
y = [7,8,3,2]
z = ['a','b','c','d']
for a,b in zip(x,y):
    print(a,b)
    
x = [1,2,3,4]
y = [7,8,3,2]
z = ['a','b','c','d']

[print(x,y,z) for x,y,z in zip(x,y,z)]
=====================================
import logging

logging.basicConfig(level=logging.INFO)
logging.basicConfig(filename='logfile.log',level=logging.INFO)


sys module
==============================
import sys
sys.stderr.write('This is stderr text\n')
sys.stderr.flush()
sys.stdout.write('This is stdout text\n')
def main(arg):
    print(arg)

main(sys.argv[1])

urllib
===============================
#Used to make requests
import urllib.request

x = urllib.request.urlopen('https://www.google.com/')
print(x.read())

import urllib.parse


url = 'https://www.google.com/search'
values = {'q' : 'python programming tutorials'}

data = urllib.parse.urlencode(values)
data = data.encode('utf-8') # data should be bytes
req = urllib.request.Request(url, data)
resp = urllib.request.urlopen(req)
respData = resp.read()

print(respData)


try:
    url = 'https://www.google.com/search?q=python'

    # now, with the below headers, we defined ourselves as a simpleton who is
    # still using internet explorer.
    headers = {}
    headers['User-Agent'] = "Mozilla/5.0 (X11; Linux i686) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.27 Safari/537.17"
    req = urllib.request.Request(url, headers = headers)
    resp = urllib.request.urlopen(req)
    respData = resp.read()

    saveFile = open('withHeaders.txt','w')
    saveFile.write(str(respData))
    saveFile.close()
except Exception as e:
    print(str(e))
    
    
Regular expressions
==============================

import re
ages = re.findall(r'\d{1,3}',exampleString)
names = re.findall(r'[A-Z][a-z]*',exampleString)

import urllib.request
import re

url = 'http://pythonprogramming.net/parse-website-using-regular-expressions-urllib/'

req = urllib.request.Request(url)
resp = urllib.request.urlopen(req)
respData = resp.read()

paragraphs = re.findall(r'<p>(.*?)</p>',str(respData))
for eachP in paragraphs:
    print(eachP)

Threading
============================

import threading
from queue import Queue
import time

print_lock = threading.Lock()
def exampleJob(worker):
    time.sleep(.5) # pretend to do some work.
    with print_lock:
        print(threading.current_thread().name,worker)
  
# The threader thread pulls an worker from the queue and processes it
def threader():
    while True:
        # gets an worker from the queue
        worker = q.get()

        # Run the example job with the avail worker in queue (thread)
        exampleJob(worker)

        # completed with the job
        q.task_done()
q = Queue()

# how many threads are we going to allow for
for x in range(10):
     t = threading.Thread(target=threader)

     # classifying as a daemon, so they will die when the main dies
     t.daemon = True

     # begins, must come after daemon definition
     t.start()

start = time.time()

# 20 jobs assigned.
for worker in range(20):
    q.put(worker)

# wait until the thread terminates.
q.join()

# with 10 workers and 20 tasks, with each task being .5 seconds, then the completed job
# is ~1 second using threading. Normally 20 tasks with .5 seconds each would take 10 seconds.
print('Entire job took:',time.time() - start)

Matplotlib
==================
from matplotlib import pyplot as plt
from matplotlib import style
import numpy as np

style.use('ggplot')

x,y = np.loadtxt('exampleFile.csv',
                 unpack=True,
                 delimiter = ',')

plt.plot(x,y)

plt.title('Epic Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')

plt.show()

####################################
from matplotlib import pyplot as plt
from matplotlib import style

style.use('ggplot')

x = [5,8,10]
y = [12,16,6]

x2 = [6,9,11]
y2 = [6,15,7]

plt.scatter(x, y)#, align='center')

plt.scatter(x2, y2, color='g')#, align='center')


plt.title('Epic Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
#########################################

from matplotlib import pyplot as plt
from matplotlib import style

style.use('ggplot')

x = [5,8,10]
y = [12,16,6]

x2 = [6,9,11]
y2 = [6,15,7]


plt.bar(x, y, align='center')

plt.bar(x2, y2, color='g', align='center')


plt.title('Epic Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')

plt.show()

======================================
plt.show()

spark code 
===================

import glob
import re
import sys
import os
from pyspark.sql import SparkSession
from datetime import datetime

pattern = '/q*sql'
filelist = []
for file in glob.glob(pattern):
    filelist.append(file)

def texttoint(text):
    return int(text) if text.isdigit() else text

def natural_keys(text):
    return [ texttoint(x) for x in re.split('(\d+)', text) ]

def filterstring(pattern, listname):
    regex= re.compile(".*("+pattern+").*")
    for i in listname:
        if regex.search(str(i)):
            return i


filelist.sort(key=natural_keys)

blacklist = ['q04.sql',
'q10.sql',
'q11.sql',
'q13.sql',
'q14.sql',
'q16.sql',
'q22.sql',
'q23.sql',
'q28.sql',
'q29.sql',
'q30.sql',
'q35.sql',
'q49.sql',
'q50.sql',
'q57.sql',
'q61.sql',
'q64.sql',
'q72.sql',
'q74.sql',
'q75.sql',
'q77.sql',
'q78.sql',
'q85.sql',
'q87.sql',
'q92.sql',
'q93.sql',
'q94.sql',
'q95.sql',
'q96.sql',
'q97.sql',
'q99.sql']

list_blacklist=[]
for i in blacklist:
    list_blacklist.append(filterstring(i, filelist))

for i in list_blacklist:
    print(i)

#sys.exit(0)

for i in filelist:
    print(i)


results=[]

logfile=sys.argv[1]


spark = SparkSession\
  .builder\
  .appName("Spark TPC DS")\
  .enableHiveSupport()\
  .getOrCreate()
print("Spark Session started.")
df1 = spark.sql("use tpcds_10")
print("Connected to tpcds_10 database in Hive.")
for i in filelist:
    print(i)
    print("The query currently being processed: " + i)
    temp=[]
    if i in list_blacklist:
        start=datetime.now()
        temp.append(i)
        temp.append(start.strftime("%y/%m/%d %H:%M"))
        temp.append(start.strftime("%y/%m/%d %H:%M"))
        diff = 999999
        temp.append(diff)
    else:
        with open(i) as f:
            content = f.read()
            t1 = content.split(';')[0]
            temp.append(i)
            start=datetime.now()
            print("start time is : " + start.strftime("%y/%m/%d %H:%M"))
            temp.append(start.strftime("%y/%m/%d %H:%M"))
            try:
                df1 = spark.sql(t1)
                df1.show()
                end=datetime.now()
                temp.append(end.strftime("%y/%m/%d %H:%M"))
                print("end time is : "+ end.strftime("%y/%m/%d %H:%M"))
                diff=end-start
                temp.append(diff.seconds)
            except:
                print("there is something wrong with " + i)
                end=datetime.now()
                temp.append(end.strftime("%y/%m/%d %H:%M"))
                print("end time is : "+ end.strftime("%y/%m/%d %H:%M"))
                diff = 999999
                temp.append(diff)
    results.append(temp)
print("completed execution")

#logfile='out_' + datetime.now().strftime('%y%m%d%H%M%S') + '.log'

with open(logfile, 'w') as o:
    for i in results:
        print(i)
        t1 = ','.join(map(str, i))
        o.write(t1 +'\n')



Find Probability from Z score 
=======================================

>>> import scipy.stats as st
>>> st.norm.ppf(.95)
1.6448536269514722
>>> st.norm.cdf(1.64)
0.94949741652589625
